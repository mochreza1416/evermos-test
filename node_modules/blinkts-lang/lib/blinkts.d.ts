declare module blinkts.lang {
    class Iterable<T> {
        /**
        * <p>Get an iterator over the iterable, that will iterate over each element.</p>
        * @abstract
        */
        public iterator(): Iterator<T>;
        /**
        * <p>Iterates over each element executing the given function with the element
        * given as a parameter.</p>
        * @param f
        * @param thisParam
        * @returns {blinkts.lang.Iterable}
        */
        public forEach(f: (it: T, index: number, iterable: Iterable<T>) => void, thisParam?: any): Iterable<T>;
        public forEachPromise(f: (it: T, index: number, iterable: Iterable<T>) => void, thisParam?: any): Promise<Iterable<T>>;
        /**
        * <p>Creates a new iterable from the giving iterable, by transforming
        * each element via the function giving as argument.<p>
        * @param f
        * @param thisParam
        * @returns {blinkts.lang.ArrayList<U>}
        */
        public map<U>(f: (it: T, index: number, iterable: Iterable<T>) => U, thisParam?: any): Iterable<U>;
        public mapPromise<U>(f: (it: T, index: number, iterable: Iterable<T>) => U, thisParam?: any): Promise<Iterable<U>>;
        public mapPromise<U>(f: (it: T, index: number, iterable: Iterable<T>) => Promise<U>, thisParam?: any): Promise<Iterable<U>>;
        public asPromises<T>(): Promise<Iterable<T>>;
        /**
        * <p>Reduces the current iterable to an item that is returned by processing
        * the elements in the iterable using the given function.</p>
        * <p>If the initialValue is passed then reduce will iterate over each element.</p>
        * <p>If the initialValue is not passed, then the first element of the iterable
        * will be the initial value of the accumulator, and the callback function will be
        * called for each element, starting with the second element.</p>
        * @param f
        * @param initialValue
        * @returns {*}
        */
        public reduce(f: (accumulator: T, item: T, index: number, iterable: Iterable<T>) => T, initialValue?: T): T;
        public reduce<TA>(f: (accumulator: TA, item: T, index: number, iterable: Iterable<T>) => T, initialValue?: TA): TA;
        public reducePromise(f: (accumulator: T, item: T, index: number, iterable: Iterable<T>) => T, initialValue?: T): Promise<T>;
        public reducePromise(f: (accumulator: T, item: T, index: number, iterable: Iterable<T>) => Promise<T>, initialValue?: T): Promise<T>;
        public reducePromise<TA>(f: (accumulator: TA, item: T, index: number, iterable: Iterable<T>) => T, initialValue?: TA): Promise<TA>;
        public reducePromise<TA>(f: (accumulator: TA, item: T, index: number, iterable: Iterable<T>) => Promise<T>, initialValue?: TA): Promise<TA>;
        /**
        * <p>Filter all the items in the iterable, keeping only the ones where the
        * condition check via the function given passes.</p>
        * @param f
        * @returns {blinkts.lang.Iterable<T>}
        */
        public filter(f: (it: T, index: number, iterable: Iterable<T>) => boolean, thisParam?: any): Iterable<T>;
        public filterPromise(f: (it: T, index: number, iterable: Iterable<T>) => boolean, thisParam?: any): Promise<Iterable<T>>;
        public filterPromise(f: (it: T, index: number, iterable: Iterable<T>) => Promise<boolean>, thisParam?: any): Promise<Iterable<T>>;
        /**
        * Join multiple elements, eventually interceding the symbol.
        * @param symbol
        * @returns {T}
        */
        public join(symbol?: string): string;
        /**
        * <p>Finds if there is at least one element in the iterable where f(it) is true.</p>
        * @param f
        * @param thisParam
        * @returns {boolean}
        */
        public some(f: (it: T, index: number, arr: Iterable<T>) => boolean, thisParam?: any): boolean;
        /**
        * Returns true if the item is in the iterable.
        * @param item The items to search for in the iterable.
        */
        public contains(item: T): boolean;
        /**
        * Returns the first element where the condition matches.
        */
        public findFirst(f: (it: T, index: number, arr: Iterable<T>) => boolean, thisParam?: any): T;
        /**
        * Returns the current iterable as a native javascript array.
        * @returns {Array}
        */
        public asArray(): T[];
        /**
        * Returns the first element from this iterable, or null if there is no item
        * in the collection..
        * @returns {T}
        */
        public first(): T;
        /**
        * Returns an interable that has all the elements, except the first element from
        * the iterable.
        */
        public butFirst(): Iterable<T>;
        /**
        * Group all the items from this iterable into a map, using the returned value from the mapping function as a key.
        * @param mappingFunction
        */
        public groupBy<V>(mappingFunction: (it: T, index: number, arr: Iterable<T>) => V): Map<V, List<T>>;
        /**
        * Calls the given function with the iterable itself as an argument, and returns the
        * result of the function.
        * @param f
        * @returns {V}
        */
        public transform<V>(f: (self: Iterable<T>) => V): V;
        public toString(): string;
    }
}
declare module blinkts.lang {
    interface Iterator<T> {
        hasNext(): boolean;
        next(): T;
    }
}
declare module blinkts.lang {
    /**
    * A Collection of items is an Iterable object that can hold zero or more other
    * objects, allowing items to be added and removed to it.
    */
    class Collection<T> extends Iterable<T> {
        /**
        * Add the given element into the collection.
        * @param {T} item Element to be added.
        * @abstract
        */
        public add(item: T): void;
        /**
        * <p>Adds all the elements from the collection given as a parameter into
        * this collection.</p>
        * @param {Collection<T>} items
        */
        public addAll(items: T[]): void;
        public addAll(items: Iterable<T>): void;
        /**
        * <p>Removes the element from the collection.</p>
        * @param item
        */
        public remove(item: T): void;
        /**
        * <p>Returns the number of stored items in the collection.</p>
        */
        public size(): number;
        /**
        * <p>Returns true if the collection has no elements.</p>
        */
        public isEmpty(): boolean;
    }
}
declare module blinkts.lang {
    /**
    * @abstract
    */
    class List<T> extends Collection<T> {
        public get(i: number): T;
        public indexOf(item: T): number;
    }
}
declare module blinkts.lang {
    /**
    * ArrayList is a very effective implementation of a list that allows fast
    * indexed access to its internal storage.
    */
    class ArrayList<T> extends List<T> {
        public storage: any[];
        constructor(items?: Iterable<T>);
        public iterator(): Iterator<T>;
        public add(o: T): void;
        public remove(o: T): void;
        public size(): number;
        public isEmpty(): boolean;
        public get(i: number): T;
    }
}
declare module blinkts.lang {
    /**
    * A list that is wrapped over an existing array, and that will
    * perform all the operations on top of the initial array.
    */
    class ArrayListView<T> extends ArrayList<T> {
        constructor(data: any);
    }
}
declare module blinkts.lang {
    class MapEntry<K, V> {
        public key: K;
        public value: V;
        constructor(key: K, value: V);
    }
    class Map<K, V> extends Collection<MapEntry<K, V>> {
        public put(key: K, value: V): void;
        public get(key: K): V;
        public removeKey(key: K): V;
        public hasKey(key: K): boolean;
        public keys(): Iterable<K>;
        public values(): Iterable<V>;
        public entries(): Iterable<MapEntry<K, V>>;
        public iterator(): Iterator<MapEntry<K, V>>;
        /**
        * Returns the current map as an object, with its keys as properties of the object.
        * @returns {Object}
        */
        public asObject(): Object;
    }
}
declare module blinkts.lang {
    class HashMap<K, V> extends Map<K, V> {
        private _storage;
        private _elementCount;
        public put(key: K, value: V): void;
        public get(key: K): V;
        public removeKey(key: K): V;
        public hasKey(key: K): boolean;
        public keys(): Iterable<K>;
        public values(): Iterable<V>;
        public entries(): Iterable<MapEntry<K, V>>;
        public size(): number;
    }
}
/**
* <p>Utilities functions for string manipulations.</p>
*/
declare module blinkts.lang.stringutils {
    /**
    * A function that formats a String, using {0}, {1}, etc as arguments for formatting.
    * @param format
    * @param args
    * @returns {string}
    */
    function format(format: string, ...args: any[]): string;
}
declare module blinkts.lang.collections {
    /**
    * Convert the given array like items object, into a List. This
    * will do a copy of the array. If you want to use the current
    * items object as the actual storage of the list, use the ArrayListView
    * class instead.
    * @param items
    */
    function list<T>(items: T[]): List<T>;
    function list<T>(items: {
        length: number;
    }): List<T>;
    /**
    * Convert the given item into a Map, using its keys as keys of the map.
    * @param item
    * @returns {blinkts.lang.HashMap<K, V>}
    */
    function map<K, V>(item: any): Map<K, V>;
    function asArray<T>(item: any): T[];
}
declare module blinkts.lang {
    /**
    * <p>A OnceMany will return the first element once when its next() method
    * will be called, and from that moment on always return the other value.</p>
    */
    class OnceMany<T> implements Iterator<T> {
        public first: T;
        public allNext: T;
        private firstPassed;
        constructor(first: T, allNext: T);
        public hasNext(): boolean;
        public next(): T;
    }
}
declare module blinkts.lang {
    class LinkedHashMap<K, V> extends HashMap<K, V> {
        private orderedKeys;
        public put(key: K, value: V): void;
        public removeKey(key: K): V;
        public keys(): Iterable<K>;
    }
}
declare module blinkts.lang {
    class Set<T> extends Collection<T> {
    }
}
declare module blinkts.lang {
    class HashSet<T> extends Set<T> {
        public _storage: any;
        constructor();
        /**
        * <p>Get an iterator over the collection, that will iterate over each element.</p>
        * @abstract
        */
        public iterator(): Iterator<T>;
        /**
        * Add the given element into the collection.
        * @param {T} item Element to be added.
        * @abstract
        */
        public add(item: T): void;
        /**
        * <p>Removes the element from the collection.</p>
        * @param item
        */
        public remove(item: T): void;
        /**
        * <p>Returns the number of stored items in the collection.</p>
        */
        public size(): number;
        /**
        * <p>Returns true if the collection has no elements.</p>
        */
        public isEmpty(): boolean;
    }
}
declare module blinkts.lang {
    function nextTick(callback: Function): void;
}
declare module blinkts.lang {
    /**
    * A promise can be in any of these states. FULFILLED and REJECTED are final states for a promise.
    */
    enum PromiseState {
        FULFILLED = 0,
        REJECTED = 1,
        PENDING = 2,
    }
    /**
    * <p>A promise represents the eventual result of an asynchronous operation. The primary way
    * of interacting with a promise is through its then method, which registers callbacks to
    * receive either a promise’s eventual value or the reason why the promise cannot be fulfilled.</p>
    * <p>This implementation is fully compatible with the specification from: http://promisesaplus.com/,
    * and passes all the tests defined here: https://github.com/promises-aplus/promises-tests.</p>
    */
    class Promise<T> {
        private state;
        private value;
        private followUps;
        /**
        * @param {object} executor A function with two parameters.
        */
        constructor(executor: (resolve: (value: any) => void, reject: (value: any) => void) => any);
        /**
        *
        * @param onFulfill
        * @param onReject
        * @returns {Promise}
        */
        public then<V>(onFulfill?: (value: T) => Promise<V>, onReject?: (reason: any) => any): Promise<V>;
        public then<V>(onFulfill?: (value: T) => V, onReject?: (reason: any) => any): Promise<V>;
        public then<V>(onFulfill?: (value: T) => void, onReject?: (reason: any) => any): Promise<T>;
        /**
        * Always permits adding some code into the promise chain that will be called
        * irrespective if the chain is successful or not, in order to be used similarily
        * with a finally block.
        * @param always
        */
        public always(fn: Function): Promise<T>;
        private transition(state, value);
        private fulfill(value);
        private reject(reason);
        private notifyCallbacks();
        static resolve<U>(x: any): Promise<U>;
        /**
        * The Promise.all(iterable) method returns a promise that resolves when all of the promises
        * in the iterable argument have resolved.
        * @param args
        * @returns {Promise<Iterable<T>>}
        */
        static all<T>(args: any[]): Promise<T[]>;
        static reject<U>(reason: any): Promise<U>;
        /**
        * Resolve a promise.
        * @param {Promise} promise     The promise to resolve.
        * @param {any} x               The value to resolve against.
        */
        static resolvePromise<U>(promise: Promise<U>, x: any): void;
        public toString(): string;
    }
    /**
    * Creates a promise that will resolve, after the promises for all the arguments will resolve.
    * This also will transform the the arguments in the following way:
    * <ul>
    *     <li>If the argument is a promise, it remains the same.</li>
    *     <li>If the argument is a function, it is transformed with promiseCode to a promise.</li>
    *     <li>If the argument is a value, it is transformed to an already fulfilled promise with the given value.</li>
    * </ul>
    * @param any
    */
    function promises<T>(...any: any[]): Promise<T[]>;
    /**
    * Creates a single promise from the given argument.
    * <ul>
    *     <li>If the argument is a promise, it remains the same.</li>
    *     <li>If the argument is a function, it is transformed with promiseCode to a promise.</li>
    *     <li>If the argument is a value, it is transformed to an already fulfilled promise with the given value.</li>
    * </ul>
    * @param data
    */
    function promise<T>(data: any): Promise<T>;
    /**
    * <p>A promise that fulfills only when all its children promises fulfill, or rejects if any of its
    * children promises reject.</p>
    * <p>In case the promise fulfills it will return the values of the children promises.</p>
    */
    function multiplePromise<T>(promises: Promise<T>[]): Promise<T[]>;
    function multiplePromise<T>(...promises: Promise<T>[]): Promise<T[]>;
    /**
    * <p>Wrap the given code as a promise, and start its immediate execution.</p>
    * <p>Note that the callback might in turn return another promise, and is subject to the
    * promise resolution algorithm.</p>
    * @param callback
    * @param reasonCallback
    * @returns {Promise}
    */
    function promiseCode<T>(callback: () => Promise<T>, reasonCallback?: () => any): Promise<T>;
    function promiseCode<T>(callback: () => T, reasonCallback?: () => any): Promise<T>;
}
