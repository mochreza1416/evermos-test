var blinkts;
(function (blinkts) {
    (function (lang) {
        var Iterable = (function () {
            function Iterable() {
            }
            /**
            * <p>Get an iterator over the iterable, that will iterate over each element.</p>
            * @abstract
            */
            Iterable.prototype.iterator = function () {
                throw new Error("Abstract method");
            };

            /**
            * <p>Iterates over each element executing the given function with the element
            * given as a parameter.</p>
            * @param f
            * @param thisParam
            * @returns {blinkts.lang.Iterable}
            */
            Iterable.prototype.forEach = function (f, thisParam) {
                var it = this.iterator(), index = 0;

                while (it.hasNext()) {
                    f.call(thisParam, it.next(), index++, this);
                }

                return this;
            };

            Iterable.prototype.forEachPromise = function (f, thisParam) {
                return this.asPromises().then(function (data) {
                    return data.forEach(f, thisParam);
                }).then(function (data) {
                    return data.asPromises();
                });
            };

            Iterable.prototype.map = function (f, thisParam) {
                var result = new blinkts.lang.ArrayList();
                this.forEach(function (it, index, arr) {
                    return result.add(f(it, index, arr));
                }, thisParam);

                return result;
            };

            Iterable.prototype.mapPromise = function (f, thisParam) {
                return this.asPromises().then(function (data) {
                    return data.map(f, thisParam);
                }).then(function (data) {
                    return data.asPromises();
                });
            };

            Iterable.prototype.asPromises = function () {
                return this.map(lang.promise).transform(function (c) {
                    return lang.promises(c.asArray());
                }).then(lang.collections.list);
            };

            Iterable.prototype.reduce = function (f, initialValue) {
                var result, firstReached = false;

                if (typeof (initialValue) !== "undefined") {
                    result = initialValue;
                    firstReached = true;
                }

                this.forEach(function (it, index, iterable) {
                    if (firstReached) {
                        result = f(result, it, index, iterable);
                    } else {
                        result = it;
                        firstReached = true;
                    }
                });

                return result;
            };

            Iterable.prototype.reducePromise = function (f, initialValue) {
                return this.asPromises().then(function (data) {
                    return data.reduce(f, initialValue);
                });
            };

            /**
            * <p>Filter all the items in the iterable, keeping only the ones where the
            * condition check via the function given passes.</p>
            * @param f
            * @returns {blinkts.lang.Iterable<T>}
            */
            Iterable.prototype.filter = function (f, thisParam) {
                var result = new blinkts.lang.ArrayList();

                this.forEach(function (it, index, iterable) {
                    if (f.call(thisParam, it, index, iterable)) {
                        result.add(it);
                    }
                }, thisParam);

                return result;
            };

            Iterable.prototype.filterPromise = function (f, thisParam) {
                var resolvedData;
                return this.asPromises().then(function (data) {
                    resolvedData = data;
                    return data.mapPromise(f);
                }).then(function (data) {
                    var iterator = data.iterator();
                    return resolvedData.filter(function () {
                        return iterator.next();
                    });
                });
            };

            /**
            * Join multiple elements, eventually interceding the symbol.
            * @param symbol
            * @returns {T}
            */
            Iterable.prototype.join = function (symbol) {
                var result = "";
                symbol = typeof symbol !== "undefined" ? symbol : ",";

                this.forEach(function (it, index) {
                    if (index == 0) {
                        result = "" + it;
                    } else {
                        if (symbol) {
                            result = result + symbol + it;
                        } else {
                            result = result + it;
                        }
                    }
                });

                return result;
            };

            /**
            * <p>Finds if there is at least one element in the iterable where f(it) is true.</p>
            * @param f
            * @param thisParam
            * @returns {boolean}
            */
            Iterable.prototype.some = function (f, thisParam) {
                var iterator = this.iterator(), index = 0;

                while (iterator.hasNext()) {
                    if (f.call(thisParam, iterator.next(), index++, this)) {
                        return true;
                    }
                }

                return false;
            };

            /**
            * Returns true if the item is in the iterable.
            * @param item The items to search for in the iterable.
            */
            Iterable.prototype.contains = function (item) {
                return this.some(function (it) {
                    return it === item;
                });
            };

            /**
            * Returns the first element where the condition matches.
            */
            Iterable.prototype.findFirst = function (f, thisParam) {
                var iterator = this.iterator(), index = 0, value;

                while (iterator.hasNext()) {
                    value = iterator.next();
                    if (f.call(thisParam, value, index++, this)) {
                        return value;
                    }
                }

                return null;
            };

            /**
            * Returns the current iterable as a native javascript array.
            * @returns {Array}
            */
            Iterable.prototype.asArray = function () {
                var result = [];

                this.forEach(function (it) {
                    result.push(it);
                });

                return result;
            };

            /**
            * Returns the first element from this iterable, or null if there is no item
            * in the collection..
            * @returns {T}
            */
            Iterable.prototype.first = function () {
                var it = this.iterator();

                return it.hasNext() ? it.next() : null;
            };

            /**
            * Returns an interable that has all the elements, except the first element from
            * the iterable.
            */
            Iterable.prototype.butFirst = function () {
                var data = this.asArray();
                data.shift();

                return blinkts.lang.collections.list(data);
            };

            /**
            * Group all the items from this iterable into a map, using the returned value from the mapping function as a key.
            * @param mappingFunction
            */
            Iterable.prototype.groupBy = function (mappingFunction) {
                var map = new blinkts.lang.HashMap(), key, list;

                this.forEach(function (it, index, arr) {
                    key = mappingFunction(it, index, arr);
                    list = map.get(key);

                    if (!list) {
                        list = new blinkts.lang.ArrayList();
                        map.put(key, list);
                    }

                    list.add(it);
                });

                return map;
            };

            /**
            * Calls the given function with the iterable itself as an argument, and returns the
            * result of the function.
            * @param f
            * @returns {V}
            */
            Iterable.prototype.transform = function (f) {
                return f(this);
            };

            Iterable.prototype.toString = function () {
                return "Iterable";
            };
            return Iterable;
        })();
        lang.Iterable = Iterable;
    })(blinkts.lang || (blinkts.lang = {}));
    var lang = blinkts.lang;
})(blinkts || (blinkts = {}));
/// <reference path="Iterator.ts"/>
/// <reference path="ArrayList.ts"/>
/// <reference path="Iterable.ts"/>
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var blinkts;
(function (blinkts) {
    (function (lang) {
        /**
        * A Collection of items is an Iterable object that can hold zero or more other
        * objects, allowing items to be added and removed to it.
        */
        var Collection = (function (_super) {
            __extends(Collection, _super);
            function Collection() {
                _super.apply(this, arguments);
            }
            /**
            * Add the given element into the collection.
            * @param {T} item Element to be added.
            * @abstract
            */
            Collection.prototype.add = function (item) {
                throw new Error("Abstract method");
            };

            Collection.prototype.addAll = function (items) {
                var _this = this;
                if (items instanceof lang.Iterable) {
                    items.forEach(function (x) {
                        return _this.add(x);
                    });
                } else {
                    for (var i = 0; i < items.length; i++) {
                        this.add(items[i]);
                    }
                }
            };

            /**
            * <p>Removes the element from the collection.</p>
            * @param item
            */
            Collection.prototype.remove = function (item) {
                throw new Error("Abstract method");
            };

            /**
            * <p>Returns the number of stored items in the collection.</p>
            */
            Collection.prototype.size = function () {
                throw new Error("Abstract method");
            };

            /**
            * <p>Returns true if the collection has no elements.</p>
            */
            Collection.prototype.isEmpty = function () {
                throw new Error("Abstract method");
            };
            return Collection;
        })(lang.Iterable);
        lang.Collection = Collection;
    })(blinkts.lang || (blinkts.lang = {}));
    var lang = blinkts.lang;
})(blinkts || (blinkts = {}));
/// <reference path="Collection.ts"/>
var blinkts;
(function (blinkts) {
    (function (lang) {
        /**
        * @abstract
        */
        var List = (function (_super) {
            __extends(List, _super);
            function List() {
                _super.apply(this, arguments);
            }
            List.prototype.get = function (i) {
                throw new Error("Abstract method");
            };

            List.prototype.indexOf = function (item) {
                var result = -1;

                this.some(function (it, index) {
                    if (it === item) {
                        result = index;
                        return true;
                    }

                    return false;
                });

                return result;
            };
            return List;
        })(lang.Collection);
        lang.List = List;
    })(blinkts.lang || (blinkts.lang = {}));
    var lang = blinkts.lang;
})(blinkts || (blinkts = {}));
/// <reference path="List.ts"/>
var blinkts;
(function (blinkts) {
    (function (lang) {
        /**
        * An iterator specific to an array list.
        */
        var ArrayListIterator = (function () {
            function ArrayListIterator(list) {
                this.index = 0;
                this.list = list;
            }
            ArrayListIterator.prototype.hasNext = function () {
                return this.index < this.list.storage.length;
            };

            ArrayListIterator.prototype.next = function () {
                return this.list.storage[this.index++];
            };
            return ArrayListIterator;
        })();

        /**
        * ArrayList is a very effective implementation of a list that allows fast
        * indexed access to its internal storage.
        */
        var ArrayList = (function (_super) {
            __extends(ArrayList, _super);
            function ArrayList(items) {
                _super.call(this);
                this.storage = [];

                if (items) {
                    this.addAll(items);
                }
            }
            ArrayList.prototype.iterator = function () {
                return new ArrayListIterator(this);
            };

            ArrayList.prototype.add = function (o) {
                this.storage.push(o);
            };

            ArrayList.prototype.remove = function (o) {
                var index = this.indexOf(o);

                if (index < 0) {
                    throw new Error("ArrayList doesn't contain item " + o);
                }

                this.storage.splice(index, 1);
            };

            ArrayList.prototype.size = function () {
                return this.storage.length;
            };

            ArrayList.prototype.isEmpty = function () {
                return this.storage.length == 0;
            };

            ArrayList.prototype.get = function (i) {
                return this.storage[i];
            };
            return ArrayList;
        })(lang.List);
        lang.ArrayList = ArrayList;
    })(blinkts.lang || (blinkts.lang = {}));
    var lang = blinkts.lang;
})(blinkts || (blinkts = {}));
/// <reference path="ArrayList.ts"/>
var blinkts;
(function (blinkts) {
    (function (lang) {
        /**
        * A list that is wrapped over an existing array, and that will
        * perform all the operations on top of the initial array.
        */
        var ArrayListView = (function (_super) {
            __extends(ArrayListView, _super);
            function ArrayListView(data) {
                _super.call(this, null);

                this.storage = data;
            }
            return ArrayListView;
        })(lang.ArrayList);
        lang.ArrayListView = ArrayListView;
    })(blinkts.lang || (blinkts.lang = {}));
    var lang = blinkts.lang;
})(blinkts || (blinkts = {}));
/// <reference path="Collection.ts"/>
var blinkts;
(function (blinkts) {
    (function (lang) {
        var MapEntry = (function () {
            function MapEntry(key, value) {
                this.key = key;
                this.value = value;
            }
            return MapEntry;
        })();
        lang.MapEntry = MapEntry;

        var Map = (function (_super) {
            __extends(Map, _super);
            function Map() {
                _super.apply(this, arguments);
            }
            Map.prototype.put = function (key, value) {
                throw new Error("Abstract method");
            };

            Map.prototype.get = function (key) {
                throw new Error("Abstract method");
            };

            Map.prototype.removeKey = function (key) {
                throw new Error("Abstract method");
            };

            Map.prototype.hasKey = function (key) {
                throw new Error("Abstract method");
            };

            Map.prototype.keys = function () {
                throw new Error("Abstract method");
            };

            Map.prototype.values = function () {
                throw new Error("Abstract method");
            };

            Map.prototype.entries = function () {
                throw new Error("Abstract method");
            };

            Map.prototype.iterator = function () {
                return this.entries().iterator();
            };

            /**
            * Returns the current map as an object, with its keys as properties of the object.
            * @returns {Object}
            */
            Map.prototype.asObject = function () {
                var result = {};

                this.forEach(function (it) {
                    result["" + it.key] = it.value;
                });

                return result;
            };
            return Map;
        })(blinkts.lang.Collection);
        lang.Map = Map;
    })(blinkts.lang || (blinkts.lang = {}));
    var lang = blinkts.lang;
})(blinkts || (blinkts = {}));
/// <reference path="Map.ts"/>
/// <reference path="ArrayList.ts"/>
var blinkts;
(function (blinkts) {
    (function (lang) {
        var HashMap = (function (_super) {
            __extends(HashMap, _super);
            function HashMap() {
                _super.apply(this, arguments);
                this._storage = {};
                this._elementCount = 0;
            }
            HashMap.prototype.put = function (key, value) {
                var k = "" + key;

                if (!this._storage.hasOwnProperty(k)) {
                    this._elementCount++;
                }

                this._storage[k] = value;
            };

            HashMap.prototype.get = function (key) {
                var k = "" + key;
                return this._storage[k];
            };

            HashMap.prototype.removeKey = function (key) {
                var k = "" + key;

                var result = this._storage[k];

                delete this._storage[k];
                this._elementCount--;

                return result;
            };

            HashMap.prototype.hasKey = function (key) {
                var k = "" + key;

                return this._storage.hasOwnProperty(k);
            };

            HashMap.prototype.keys = function () {
                var k, result = new lang.ArrayList();

                for (k in this._storage) {
                    result.add(k);
                }

                return result;
            };

            HashMap.prototype.values = function () {
                var _this = this;
                return this.keys().map(function (k) {
                    return _this.get(k);
                });
            };

            HashMap.prototype.entries = function () {
                var _this = this;
                return this.keys().map(function (k) {
                    return new lang.MapEntry(k, _this.get(k));
                });
            };

            HashMap.prototype.size = function () {
                return this._elementCount;
            };
            return HashMap;
        })(blinkts.lang.Map);
        lang.HashMap = HashMap;
    })(blinkts.lang || (blinkts.lang = {}));
    var lang = blinkts.lang;
})(blinkts || (blinkts = {}));
var blinkts;
(function (blinkts) {
    (function (lang) {
        /**
        * <p>Utilities functions for string manipulations.</p>
        */
        (function (stringutils) {
            /**
            * A function that formats a String, using {0}, {1}, etc as arguments for formatting.
            * @param format
            * @param args
            * @returns {string}
            */
            function format(format) {
                var args = [];
                for (var _i = 0; _i < (arguments.length - 1); _i++) {
                    args[_i] = arguments[_i + 1];
                }
                // we're not doing regexp for performance reasons.
                var result = "", parameterIndex, foundToken = false, lastTokenFound = 0, j;

                for (var i = 0; i < format.length; i++) {
                    if (format[i] == "{") {
                        foundToken = false;

                        j = i + 1;

                        while (format[j] != '}' && format[j] >= '0' && format[j] <= '9' && j < format.length) {
                            j++;
                        }

                        if (j < format.length && format[j] == '}' && j - i > 1) {
                            foundToken = true;
                        } else {
                            i = j - 1; // no tokens until here.
                            continue;
                        }

                        // since i and j land on brackets, make sure we cut the parameter right.
                        parameterIndex = parseInt(format.substring(i + 1, j));

                        if (parameterIndex < args.length) {
                            result += format.substring(lastTokenFound, i) + args[parameterIndex];
                        }

                        lastTokenFound = j + 1;
                    }
                }

                result += format.substring(lastTokenFound, format.length);

                return result;
            }
            stringutils.format = format;
        })(lang.stringutils || (lang.stringutils = {}));
        var stringutils = lang.stringutils;
    })(blinkts.lang || (blinkts.lang = {}));
    var lang = blinkts.lang;
})(blinkts || (blinkts = {}));
/// <reference path="ArrayList.ts"/>
/// <reference path="HashMap.ts"/>
var blinkts;
(function (blinkts) {
    (function (lang) {
        (function (collections) {
            

            function list(items) {
                var result = new lang.ArrayList();

                for (var i = 0; i < items.length; i++) {
                    result.add(items[i]);
                }

                return result;
            }
            collections.list = list;

            /**
            * Convert the given item into a Map, using its keys as keys of the map.
            * @param item
            * @returns {blinkts.lang.HashMap<K, V>}
            */
            function map(item) {
                var k, result = new lang.HashMap();

                for (k in item) {
                    if (item.hasOwnProperty(k)) {
                        result.put(k, item[k]);
                    }
                }

                return result;
            }
            collections.map = map;

            function asArray(item) {
                return item.asArray();
            }
            collections.asArray = asArray;
        })(lang.collections || (lang.collections = {}));
        var collections = lang.collections;
    })(blinkts.lang || (blinkts.lang = {}));
    var lang = blinkts.lang;
})(blinkts || (blinkts = {}));
var blinkts;
(function (blinkts) {
    (function (lang) {
        /**
        * <p>A OnceMany will return the first element once when its next() method
        * will be called, and from that moment on always return the other value.</p>
        */
        var OnceMany = (function () {
            function OnceMany(first, allNext) {
                this.first = first;
                this.allNext = allNext;
                this.firstPassed = false;
            }
            OnceMany.prototype.hasNext = function () {
                return true;
            };

            OnceMany.prototype.next = function () {
                if (this.firstPassed) {
                    return this.allNext;
                }

                this.firstPassed = true;

                return this.first;
            };
            return OnceMany;
        })();
        lang.OnceMany = OnceMany;
    })(blinkts.lang || (blinkts.lang = {}));
    var lang = blinkts.lang;
})(blinkts || (blinkts = {}));
var blinkts;
(function (blinkts) {
    (function (lang) {
        var LinkedHashMap = (function (_super) {
            __extends(LinkedHashMap, _super);
            function LinkedHashMap() {
                _super.apply(this, arguments);
                this.orderedKeys = new lang.ArrayList();
            }
            LinkedHashMap.prototype.put = function (key, value) {
                if (!this.orderedKeys.contains(key)) {
                    this.orderedKeys.add(key);
                }

                _super.prototype.put.call(this, key, value);
            };

            LinkedHashMap.prototype.removeKey = function (key) {
                this.orderedKeys.remove(key);
                return _super.prototype.removeKey.call(this, key);
            };

            LinkedHashMap.prototype.keys = function () {
                return this.orderedKeys;
            };
            return LinkedHashMap;
        })(blinkts.lang.HashMap);
        lang.LinkedHashMap = LinkedHashMap;
    })(blinkts.lang || (blinkts.lang = {}));
    var lang = blinkts.lang;
})(blinkts || (blinkts = {}));
/// <reference path="Collection.ts"/>
var blinkts;
(function (blinkts) {
    (function (lang) {
        var Collection = blinkts.lang.Collection;

        var Set = (function (_super) {
            __extends(Set, _super);
            function Set() {
                _super.apply(this, arguments);
            }
            return Set;
        })(Collection);
        lang.Set = Set;
    })(blinkts.lang || (blinkts.lang = {}));
    var lang = blinkts.lang;
})(blinkts || (blinkts = {}));
/// <reference path="Set.ts"/>
/// <reference path="Iterator.ts"/>
var blinkts;
(function (blinkts) {
    (function (lang) {
        var Set = blinkts.lang.Set;

        var HashSetIterator = (function () {
            function HashSetIterator(iteratedSet) {
                this._values = [];
                for (var key in iteratedSet._storage) {
                    this._values.push(key);
                }
            }
            HashSetIterator.prototype.hasNext = function () {
                return this._values.length > 0;
            };

            HashSetIterator.prototype.next = function () {
                return this._values.shift();
            };
            return HashSetIterator;
        })();

        var HashSet = (function (_super) {
            __extends(HashSet, _super);
            function HashSet() {
                _super.call(this);

                this._storage = {};
            }
            /**
            * <p>Get an iterator over the collection, that will iterate over each element.</p>
            * @abstract
            */
            HashSet.prototype.iterator = function () {
                return new HashSetIterator(this);
            };

            /**
            * Add the given element into the collection.
            * @param {T} item Element to be added.
            * @abstract
            */
            HashSet.prototype.add = function (item) {
                this._storage[item] = item;
            };

            /**
            * <p>Removes the element from the collection.</p>
            * @param item
            */
            HashSet.prototype.remove = function (item) {
                delete this._storage[item];
            };

            /**
            * <p>Returns the number of stored items in the collection.</p>
            */
            HashSet.prototype.size = function () {
                var count = 0;

                for (var key in this._storage) {
                    count++;
                }

                return count;
            };

            /**
            * <p>Returns true if the collection has no elements.</p>
            */
            HashSet.prototype.isEmpty = function () {
                var key;

                for (key in this._storage) {
                    return false;
                }

                return true;
            };
            return HashSet;
        })(Set);
        lang.HashSet = HashSet;
    })(blinkts.lang || (blinkts.lang = {}));
    var lang = blinkts.lang;
})(blinkts || (blinkts = {}));
var blinkts;
(function (blinkts) {
    (function (lang) {
        var callbacks = [], nextTickPointer = internalNextTick;

        function nextTick(callback) {
            nextTickPointer(callback);
        }
        lang.nextTick = nextTick;

        function internalNextTick(callback) {
            callbacks.push(callback);
            setTimeout(runTicks, 0);
        }

        function addCallback(callback) {
            callbacks.push(callback);
        }

        function runTicks() {
            var fn;

            try  {
                nextTickPointer = addCallback;

                while (fn = callbacks.shift()) {
                    fn.apply(undefined, []);
                }
            } finally {
                nextTickPointer = internalNextTick;
            }
        }
    })(blinkts.lang || (blinkts.lang = {}));
    var lang = blinkts.lang;
})(blinkts || (blinkts = {}));
/// <reference path="nextTick.ts"/>
var blinkts;
(function (blinkts) {
    (function (lang) {
        /**
        * A promise can be in any of these states. FULFILLED and REJECTED are final states for a promise.
        */
        (function (PromiseState) {
            PromiseState[PromiseState["FULFILLED"] = 0] = "FULFILLED";
            PromiseState[PromiseState["REJECTED"] = 1] = "REJECTED";
            PromiseState[PromiseState["PENDING"] = 2] = "PENDING";
        })(lang.PromiseState || (lang.PromiseState = {}));
        var PromiseState = lang.PromiseState;

        /**
        * <p>A promise follow up is a set of callbacks, followed by the next promise that are
        * registered on the "then" method of the Promise.</p>
        * <p>The callback function for onFulfill, or onReject will be called at most once as per
        * Promises spec.</p>
        */
        var PromiseFollowUp = (function () {
            function PromiseFollowUp() {
                this.callbacks = [null, null];
                this.promise = null;
            }
            return PromiseFollowUp;
        })();

        /**
        * <p>A promise represents the eventual result of an asynchronous operation. The primary way
        * of interacting with a promise is through its then method, which registers callbacks to
        * receive either a promise’s eventual value or the reason why the promise cannot be fulfilled.</p>
        * <p>This implementation is fully compatible with the specification from: http://promisesaplus.com/,
        * and passes all the tests defined here: https://github.com/promises-aplus/promises-tests.</p>
        */
        var Promise = (function () {
            function Promise(executor) {
                var _this = this;
                this.state = 2 /* PENDING */;
                this.followUps = [];
                if (!executor) {
                    throw new Error("You need an executor(resolve, reject) to be passed to " + "the constructor of a Promise");
                }

                executor(function (r) {
                    _this.fulfill(r);
                }, function (e) {
                    _this.reject(e);
                });
            }
            Promise.prototype.then = function (onFulfill, onReject) {
                var followUp = new PromiseFollowUp();

                if (typeof onFulfill === "function") {
                    followUp.callbacks[0 /* FULFILLED */] = onFulfill;
                }

                if (typeof onReject === "function") {
                    followUp.callbacks[1 /* REJECTED */] = onReject;
                }

                followUp.promise = new Promise(function (fulfill, reject) {
                });
                this.followUps.push(followUp);

                this.notifyCallbacks();

                return followUp.promise;
            };

            /**
            * Always permits adding some code into the promise chain that will be called
            * irrespective if the chain is successful or not, in order to be used similarily
            * with a finally block.
            * @param always
            */
            Promise.prototype.always = function (fn) {
                return this.then(function (result) {
                    fn.apply(undefined);
                    return result;
                }, function (reason) {
                    fn.apply(undefined);
                    throw reason;
                });
            };

            Promise.prototype.transition = function (state, value) {
                if (this.state == 2 /* PENDING */) {
                    this.state = state;
                    this.value = value;

                    this.notifyCallbacks();
                }
            };

            Promise.prototype.fulfill = function (value) {
                this.transition(0 /* FULFILLED */, value);

                return this;
            };

            Promise.prototype.reject = function (reason) {
                this.transition(1 /* REJECTED */, reason);

                return this;
            };

            Promise.prototype.notifyCallbacks = function () {
                var _this = this;
                if (this.state !== 2 /* PENDING */) {
                    lang.nextTick(function () {
                        var followUps = _this.followUps;
                        _this.followUps = [];

                        for (var i = 0; i < followUps.length; i++) {
                            try  {
                                if (followUps[i].callbacks[_this.state] == null) {
                                    followUps[i].promise.transition(_this.state, _this.value);
                                } else {
                                    var result = followUps[i].callbacks[_this.state].call(undefined, _this.value);
                                    Promise.resolvePromise(followUps[i].promise, result);
                                }
                            } catch (e) {
                                followUps[i].promise.transition(1 /* REJECTED */, e);
                            }
                        }
                    });
                }
            };

            Promise.resolve = function (x) {
                var result = new Promise(function (fulfill, reject) {
                });

                Promise.resolvePromise(result, x);

                return result;
            };

            /**
            * The Promise.all(iterable) method returns a promise that resolves when all of the promises
            * in the iterable argument have resolved.
            * @param args
            * @returns {Promise<Iterable<T>>}
            */
            Promise.all = function (args) {
                var promises = [];

                for (var i = 0; i < args.length; i++) {
                    promises.push(Promise.resolve(args[i]));
                }

                return multiplePromise(promises);
            };

            Promise.reject = function (reason) {
                return new Promise(function (fulfill, reject) {
                    reject(reason);
                });
            };

            /**
            * Resolve a promise.
            * @param {Promise} promise     The promise to resolve.
            * @param {any} x               The value to resolve against.
            */
            Promise.resolvePromise = function (promise, x) {
                if (promise === x) {
                    throw new TypeError();
                }

                if ((typeof x !== "function") && (typeof x !== "object") || !x) {
                    promise.fulfill(x);
                    return;
                }

                if (x instanceof Promise) {
                    x.then(function (v) {
                        promise.fulfill(v);
                    }, function (r) {
                        promise.reject(r);
                    });
                    return;
                }

                var then;
                try  {
                    then = x.then;
                } catch (e) {
                    promise.reject(e);
                    return;
                }

                var execute = true;
                if (typeof then === "function") {
                    try  {
                        then.call(x, function (value) {
                            if (execute) {
                                execute = false;
                                Promise.resolvePromise(promise, value);
                            }
                        }, function (reason) {
                            if (execute) {
                                execute = false;
                                promise.reject(reason);
                            }
                        });
                    } catch (e) {
                        if (execute) {
                            promise.reject(e);
                        }
                    }
                } else {
                    promise.fulfill(x);
                }
            };

            Promise.prototype.toString = function () {
                return "Promise";
            };
            return Promise;
        })();
        lang.Promise = Promise;

        /**
        * Creates a promise that will resolve, after the promises for all the arguments will resolve.
        * This also will transform the the arguments in the following way:
        * <ul>
        *     <li>If the argument is a promise, it remains the same.</li>
        *     <li>If the argument is a function, it is transformed with promiseCode to a promise.</li>
        *     <li>If the argument is a value, it is transformed to an already fulfilled promise with the given value.</li>
        * </ul>
        * @param any
        */
        function promises() {
            var any = [];
            for (var _i = 0; _i < (arguments.length - 0); _i++) {
                any[_i] = arguments[_i + 0];
            }
            if ((arguments.length == 1) && (arguments[0] instanceof Array)) {
                arguments = arguments[0];
            }

            var promises = [];

            for (var i = 0; i < arguments.length; i++) {
                promises.push(promise(arguments[i]));
            }

            return multiplePromise(promises);
        }
        lang.promises = promises;

        /**
        * Creates a single promise from the given argument.
        * <ul>
        *     <li>If the argument is a promise, it remains the same.</li>
        *     <li>If the argument is a function, it is transformed with promiseCode to a promise.</li>
        *     <li>If the argument is a value, it is transformed to an already fulfilled promise with the given value.</li>
        * </ul>
        * @param data
        */
        function promise(data) {
            if (data instanceof Function) {
                return promiseCode(data);
            }

            return Promise.resolve(data);
        }
        lang.promise = promise;

        

        function multiplePromise() {
            var any = [];
            for (var _i = 0; _i < (arguments.length - 0); _i++) {
                any[_i] = arguments[_i + 0];
            }
            var args = arguments;

            return new Promise(function (fulfill, reject) {
                var slice = Array.prototype.slice, promises = slice(args), promiseCount = 0, i;

                if (args.length == 1 && args[0] instanceof Array) {
                    promises = args[0];
                }

                promiseCount = promises.length;

                for (i = 0; i < promises.length; i++) {
                    promises[i].then(function () {
                        promiseCount--;

                        if (promiseCount == 0) {
                            fulfill(promises.map(function (promise) {
                                return promise.value;
                            }));
                        }
                    }, function (reason) {
                        reject(reason);
                    });
                }
            });
        }
        lang.multiplePromise = multiplePromise;

        

        function promiseCode(callback, reasonCallback) {
            return new Promise(function (fulfill, reject) {
                try  {
                    var result = callback();

                    Promise.resolve(result).then(fulfill, reject);
                } catch (e) {
                    reject(e);
                }
            });
        }
        lang.promiseCode = promiseCode;
    })(blinkts.lang || (blinkts.lang = {}));
    var lang = blinkts.lang;
})(blinkts || (blinkts = {}));
/// <module name="blinkts.lang"/>
/// <reference path="Iterable.ts"/>
/// <reference path="ArrayList.ts"/>
/// <reference path="ArrayListView.ts"/>
/// <reference path="HashMap.ts"/>
/// <reference path="StringUtils.ts"/>
/// <reference path="collections.ts"/>
/// <reference path="OnceMany.ts"/>
/// <reference path="LinkedHashMap.ts"/>
/// <reference path="Set.ts"/>
/// <reference path="HashSet.ts"/>
/// <reference path="Promise.ts"/>
/// <reference path="../../main/ts/blinkts/lang/pack.ts"/>
for (var key in blinkts) { exports[key] = blinkts[key]; }
